; generated by ARM C/C++ Compiler, 4.1 [Build 567]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_flash.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\source\wlib\ÏµÍ³Ê±ÖÓÅäÖÃ -I.\source\wlib\delay -I..\uvsion -I"D:\Program Files\keil4.14\ARM\INC" -I"D:\Program Files\keil4.14\ARM\INC\ST\STM32F10x" -D__MICROLIB --omf_browse=.\obj\stm32f10x_flash.crf source\FWLib\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;813    *******************************************************************************/
;;;814    void FLASH_ClearFlag(u16 FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;815    {
;;;816      /* Check the parameters */
;;;817      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;818      
;;;819      /* Clear the flags */
;;;820      FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;821    }
000004  4770              BX       lr
;;;822    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;457    *******************************************************************************/
;;;458    FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;459    {
000004  4604              MOV      r4,r0
;;;460      u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;461      
;;;462      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;463      
;;;464      /* Check the parameters */
;;;465      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;466      
;;;467      FLASH_Pages = (u32)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;468      WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;469      WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;470      WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;471      WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;472      
;;;473      /* Wait for last operation to be completed */
;;;474      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;475      
;;;476      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13e              BNE      |L2.172|
;;;477      {
;;;478        /* Authorizes the small information block programming */
;;;479        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;480        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;481        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;482    
;;;483        if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d006              BEQ      |L2.84|
;;;484        {
;;;485          OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;486          
;;;487          /* Wait for last operation to be completed */
;;;488          status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  f04f000f          MOV      r0,#0xf
00004e  f7fffffe          BL       FLASH_WaitForLastOperation
000052  4605              MOV      r5,r0
                  |L2.84|
;;;489        }
;;;490        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000054  2d04              CMP      r5,#4
000056  d108              BNE      |L2.106|
000058  2fff              CMP      r7,#0xff
00005a  d006              BEQ      |L2.106|
;;;491        {
;;;492          OB->WRP1 = WRP1_Data;
00005c  4819              LDR      r0,|L2.196|
00005e  8007              STRH     r7,[r0,#0]
;;;493          
;;;494          /* Wait for last operation to be completed */
;;;495          status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  f04f000f          MOV      r0,#0xf
000064  f7fffffe          BL       FLASH_WaitForLastOperation
000068  4605              MOV      r5,r0
                  |L2.106|
;;;496        }
;;;497    
;;;498        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
00006a  2d04              CMP      r5,#4
00006c  d109              BNE      |L2.130|
00006e  f1b80fff          CMP      r8,#0xff
000072  d006              BEQ      |L2.130|
;;;499        {
;;;500          OB->WRP2 = WRP2_Data;
000074  4814              LDR      r0,|L2.200|
000076  f8a0880c          STRH     r8,[r0,#0x80c]
;;;501          
;;;502          /* Wait for last operation to be completed */
;;;503          status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  200f              MOVS     r0,#0xf
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;504        }
;;;505        
;;;506        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d109              BNE      |L2.154|
000086  f1b90fff          CMP      r9,#0xff
00008a  d006              BEQ      |L2.154|
;;;507        {
;;;508          OB->WRP3 = WRP3_Data;
00008c  480e              LDR      r0,|L2.200|
00008e  f8a0980e          STRH     r9,[r0,#0x80e]
;;;509         
;;;510          /* Wait for last operation to be completed */
;;;511          status = FLASH_WaitForLastOperation(ProgramTimeout);
000092  200f              MOVS     r0,#0xf
000094  f7fffffe          BL       FLASH_WaitForLastOperation
000098  4605              MOV      r5,r0
                  |L2.154|
;;;512        }
;;;513              
;;;514        if(status != FLASH_BUSY)
00009a  2d01              CMP      r5,#1
00009c  d006              BEQ      |L2.172|
;;;515        {
;;;516          /* if the program operation is completed, disable the OPTPG Bit */
;;;517          FLASH->CR &= CR_OPTPG_Reset;
00009e  4806              LDR      r0,|L2.184|
0000a0  6900              LDR      r0,[r0,#0x10]
0000a2  f64171ef          MOV      r1,#0x1fef
0000a6  4008              ANDS     r0,r0,r1
0000a8  4903              LDR      r1,|L2.184|
0000aa  6108              STR      r0,[r1,#0x10]
                  |L2.172|
;;;518        }
;;;519      } 
;;;520      /* Return the write protection operation Status */
;;;521      return status;       
0000ac  4628              MOV      r0,r5
;;;522    }
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;523    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808
                  |L2.196|
                          DCD      0x1ffff80a
                  |L2.200|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;211    *******************************************************************************/
;;;212    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;213    {
;;;214      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;215    
;;;216      /* Wait for last operation to be completed */
;;;217      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;218      
;;;219      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d118              BNE      |L3.68|
;;;220      {
;;;221        /* if the previous operation is completed, proceed to erase all pages */
;;;222         FLASH->CR |= CR_MER_Set;
000012  480d              LDR      r0,|L3.72|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490b              LDR      r1,|L3.72|
00001c  6108              STR      r0,[r1,#0x10]
;;;223         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;224        
;;;225        /* Wait for last operation to be completed */
;;;226        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f64070ff          MOV      r0,#0xfff
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;227    
;;;228        if(status != FLASH_BUSY)
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L3.68|
;;;229        {
;;;230          /* if the erase operation is completed, disable the MER Bit */
;;;231          FLASH->CR &= CR_MER_Reset;
000036  4804              LDR      r0,|L3.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fb          MOV      r1,#0x1ffb
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L3.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L3.68|
;;;232        }
;;;233      }	   
;;;234      /* Return the Erase Status */
;;;235      return status;
000044  4620              MOV      r0,r4
;;;236    }
000046  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L3.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;246    *******************************************************************************/
;;;247    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;250      
;;;251      /* Wait for last operation to be completed */
;;;252      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;253    
;;;254      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d13c              BNE      |L4.140|
;;;255      {
;;;256        /* Authorize the small information block programming */
;;;257        FLASH->OPTKEYR = FLASH_KEY1;
000012  481f              LDR      r0,|L4.144|
000014  491f              LDR      r1,|L4.148|
000016  6088              STR      r0,[r1,#8]
;;;258        FLASH->OPTKEYR = FLASH_KEY2;
000018  481f              LDR      r0,|L4.152|
00001a  6088              STR      r0,[r1,#8]
;;;259        
;;;260        /* if the previous operation is completed, proceed to erase the option bytes */
;;;261        FLASH->CR |= CR_OPTER_Set;
00001c  4608              MOV      r0,r1
00001e  6900              LDR      r0,[r0,#0x10]
000020  f0400020          ORR      r0,r0,#0x20
000024  6108              STR      r0,[r1,#0x10]
;;;262        FLASH->CR |= CR_STRT_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400040          ORR      r0,r0,#0x40
00002e  6108              STR      r0,[r1,#0x10]
;;;263    
;;;264        /* Wait for last operation to be completed */
;;;265        status = FLASH_WaitForLastOperation(EraseTimeout);
000030  f64070ff          MOV      r0,#0xfff
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;266        
;;;267        if(status == FLASH_COMPLETE)
00003a  2c04              CMP      r4,#4
00003c  d11d              BNE      |L4.122|
;;;268        {
;;;269          /* if the erase operation is completed, disable the OPTER Bit */
;;;270          FLASH->CR &= CR_OPTER_Reset;
00003e  4815              LDR      r0,|L4.148|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171df          MOV      r1,#0x1fdf
000046  4008              ANDS     r0,r0,r1
000048  4912              LDR      r1,|L4.148|
00004a  6108              STR      r0,[r1,#0x10]
;;;271           
;;;272          /* Enable the Option Bytes Programming operation */
;;;273          FLASH->CR |= CR_OPTPG_Set;
00004c  4608              MOV      r0,r1
00004e  6900              LDR      r0,[r0,#0x10]
000050  f0400010          ORR      r0,r0,#0x10
000054  6108              STR      r0,[r1,#0x10]
;;;274    
;;;275          /* Enable the readout access */
;;;276          OB->RDP= RDP_Key; 
000056  20a5              MOVS     r0,#0xa5
000058  4910              LDR      r1,|L4.156|
00005a  8008              STRH     r0,[r1,#0]
;;;277    
;;;278          /* Wait for last operation to be completed */
;;;279          status = FLASH_WaitForLastOperation(ProgramTimeout);
00005c  f04f000f          MOV      r0,#0xf
000060  f7fffffe          BL       FLASH_WaitForLastOperation
000064  4604              MOV      r4,r0
;;;280     
;;;281          if(status != FLASH_BUSY)
000066  2c01              CMP      r4,#1
000068  d010              BEQ      |L4.140|
;;;282          {
;;;283            /* if the program operation is completed, disable the OPTPG Bit */
;;;284            FLASH->CR &= CR_OPTPG_Reset;
00006a  480a              LDR      r0,|L4.148|
00006c  6900              LDR      r0,[r0,#0x10]
00006e  f64171ef          MOV      r1,#0x1fef
000072  4008              ANDS     r0,r0,r1
000074  4907              LDR      r1,|L4.148|
000076  6108              STR      r0,[r1,#0x10]
000078  e008              B        |L4.140|
                  |L4.122|
;;;285          }
;;;286        }
;;;287        else
;;;288        {
;;;289          if (status != FLASH_BUSY)
00007a  2c01              CMP      r4,#1
00007c  d006              BEQ      |L4.140|
;;;290          {
;;;291            /* Disable the OPTPG Bit */
;;;292            FLASH->CR &= CR_OPTPG_Reset;
00007e  4805              LDR      r0,|L4.148|
000080  6900              LDR      r0,[r0,#0x10]
000082  f64171ef          MOV      r1,#0x1fef
000086  4008              ANDS     r0,r0,r1
000088  4902              LDR      r1,|L4.148|
00008a  6108              STR      r0,[r1,#0x10]
                  |L4.140|
;;;293          }
;;;294        }  
;;;295      }
;;;296      /* Return the erase status */
;;;297      return status;
00008c  4620              MOV      r0,r4
;;;298    }
00008e  bd10              POP      {r4,pc}
;;;299    
                          ENDP

                  |L4.144|
                          DCD      0x45670123
                  |L4.148|
                          DCD      0x40022000
                  |L4.152|
                          DCD      0xcdef89ab
                  |L4.156|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;172    *******************************************************************************/
;;;173    FLASH_Status FLASH_ErasePage(u32 Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;174    {
000002  4605              MOV      r5,r0
;;;175      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;176    
;;;177      /* Check the parameters */
;;;178      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;179    
;;;180      /* Wait for last operation to be completed */
;;;181      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;182      
;;;183      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d119              BNE      |L5.72|
;;;184      { 
;;;185        /* if the previous operation is completed, proceed to erase the page */
;;;186        FLASH->CR|= CR_PER_Set;
000014  480d              LDR      r0,|L5.76|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490b              LDR      r1,|L5.76|
00001e  6108              STR      r0,[r1,#0x10]
;;;187        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6145              STR      r5,[r0,#0x14]
;;;188        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;189        
;;;190        /* Wait for last operation to be completed */
;;;191        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f64070ff          MOV      r0,#0xfff
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4604              MOV      r4,r0
;;;192    
;;;193        if(status != FLASH_BUSY)
000036  2c01              CMP      r4,#1
000038  d006              BEQ      |L5.72|
;;;194        {
;;;195          /* if the erase operation is completed, disable the PER Bit */
;;;196          FLASH->CR &= CR_PER_Reset;
00003a  4804              LDR      r0,|L5.76|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f64171fd          MOV      r1,#0x1ffd
000042  4008              ANDS     r0,r0,r1
000044  4901              LDR      r1,|L5.76|
000046  6108              STR      r0,[r1,#0x10]
                  |L5.72|
;;;197        }
;;;198      }
;;;199      /* Return the Erase Status */
;;;200      return status;
000048  4620              MOV      r0,r4
;;;201    }
00004a  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP

                  |L5.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;768    *******************************************************************************/
;;;769    FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;770    {
;;;771      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;772    
;;;773      /* Check the parameters */
;;;774      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;775    
;;;776      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L6.26|
;;;777      {
;;;778        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
000008  4a08              LDR      r2,|L6.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0120f01          TST      r2,#1
000010  d001              BEQ      |L6.22|
;;;779        {
;;;780          bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L6.40|
                  |L6.22|
;;;781        }
;;;782        else
;;;783        {
;;;784          bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L6.40|
                  |L6.26|
;;;785        }
;;;786      }
;;;787      else
;;;788      {
;;;789       if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
00001a  4a04              LDR      r2,|L6.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  420a              TST      r2,r1
000020  d001              BEQ      |L6.38|
;;;790        {
;;;791          bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L6.40|
                  |L6.38|
;;;792        }
;;;793        else
;;;794        {
;;;795          bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L6.40|
;;;796        }
;;;797      }
;;;798      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;799      return bitstatus;
;;;800    }
000028  4770              BX       lr
;;;801    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;710    *******************************************************************************/
;;;711    FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;712    {
;;;713      FlagStatus bitstatus = RESET;
;;;714      
;;;715      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
000002  4904              LDR      r1,|L7.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0110f20          TST      r1,#0x20
00000a  d001              BEQ      |L7.16|
;;;716      {
;;;717        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;718      }
;;;719      else
;;;720      {
;;;721        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;722      }
;;;723      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;724      return bitstatus; 
;;;725    }
000012  4770              BX       lr
;;;726    
                          ENDP

                  |L7.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;688    *******************************************************************************/
;;;689    FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;690    {
;;;691      FlagStatus readoutstatus = RESET;
;;;692    
;;;693      if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
000002  4904              LDR      r1,|L8.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0110f02          TST      r1,#2
00000a  d001              BEQ      |L8.16|
;;;694      {
;;;695        readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L8.18|
                  |L8.16|
;;;696      }
;;;697      else
;;;698      {
;;;699        readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;700      }
;;;701      return readoutstatus;
;;;702    }
000012  4770              BX       lr
;;;703    
                          ENDP

                  |L8.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;830    *******************************************************************************/
;;;831    FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;832    {
;;;833      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;834      
;;;835      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490c              LDR      r1,|L9.52|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  2901              CMP      r1,#1
00000c  d101              BNE      |L9.18|
;;;836      {
;;;837        flashstatus = FLASH_BUSY;
00000e  2001              MOVS     r0,#1
000010  e00e              B        |L9.48|
                  |L9.18|
;;;838      }
;;;839      else 
;;;840      {  
;;;841        if(FLASH->SR & FLASH_FLAG_PGERR)
000012  4908              LDR      r1,|L9.52|
000014  68c9              LDR      r1,[r1,#0xc]
000016  f0110f04          TST      r1,#4
00001a  d001              BEQ      |L9.32|
;;;842        { 
;;;843          flashstatus = FLASH_ERROR_PG;
00001c  2002              MOVS     r0,#2
00001e  e007              B        |L9.48|
                  |L9.32|
;;;844        }
;;;845        else 
;;;846        {
;;;847          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
000020  4904              LDR      r1,|L9.52|
000022  68c9              LDR      r1,[r1,#0xc]
000024  f0110f10          TST      r1,#0x10
000028  d001              BEQ      |L9.46|
;;;848          {
;;;849            flashstatus = FLASH_ERROR_WRP;
00002a  2003              MOVS     r0,#3
00002c  e000              B        |L9.48|
                  |L9.46|
;;;850          }
;;;851          else
;;;852          {
;;;853            flashstatus = FLASH_COMPLETE;
00002e  2004              MOVS     r0,#4
                  |L9.48|
;;;854          }
;;;855        }
;;;856      }
;;;857      /* Return the Flash Status */
;;;858      return flashstatus;
;;;859    }
000030  4770              BX       lr
;;;860    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;661    *******************************************************************************/
;;;662    u32 FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L10.8|
;;;663    {
;;;664      /* Return the User Option Byte */
;;;665      return (u32)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;666    }
000006  4770              BX       lr
;;;667    
                          ENDP

                  |L10.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;674    *******************************************************************************/
;;;675    u32 FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L11.8|
;;;676    {
;;;677      /* Return the Falsh write protection Register value */
;;;678      return (u32)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;679    }
000004  4770              BX       lr
;;;680    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;105    *******************************************************************************/
;;;106    void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L12.24|
;;;107    {
;;;108      /* Check the parameters */
;;;109      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;110      
;;;111      /* Enable or disable the Half cycle access */
;;;112      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L12.24|
00000a  6011              STR      r1,[r2,#0]
;;;113      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;114    }
000014  4770              BX       lr
;;;115    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;737    *******************************************************************************/
;;;738    void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;739    {
;;;740      /* Check the parameters */
;;;741      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;742      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;743    
;;;744      if(NewState != DISABLE)
;;;745      {
;;;746        /* Enable the interrupt sources */
;;;747        FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L13.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;748      }
;;;749      else
;;;750      {
;;;751        /* Disable the interrupt sources */
;;;752        FLASH->CR &= ~(u32)FLASH_IT;
00000e  4a03              LDR      r2,|L13.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L13.24|
;;;753      }
;;;754    }
000018  4770              BX       lr
;;;755    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;157    *******************************************************************************/
;;;158    void FLASH_Lock(void)
000000  4803              LDR      r0,|L14.16|
;;;159    {
;;;160      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;161      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L14.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;162    }
00000c  4770              BX       lr
;;;163    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;125    *******************************************************************************/
;;;126    void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L15.24|
;;;127    {
;;;128      /* Check the parameters */
;;;129      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;130      
;;;131      /* Enable or disable the Prefetch Buffer */
;;;132      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L15.24|
00000a  6011              STR      r1,[r2,#0]
;;;133      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;134    }
000014  4770              BX       lr
;;;135    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;368    *******************************************************************************/
;;;369    FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;371      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;372    
;;;373      /* Check the parameters */
;;;374      assert_param(IS_FLASH_ADDRESS(Address));
;;;375    
;;;376      /* Wait for last operation to be completed */
;;;377      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;378      
;;;379      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d113              BNE      |L16.60|
;;;380      {
;;;381        /* if the previous operation is completed, proceed to program the new data */
;;;382        FLASH->CR |= CR_PG_Set;
000014  480a              LDR      r0,|L16.64|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4908              LDR      r1,|L16.64|
00001e  6108              STR      r0,[r1,#0x10]
;;;383      
;;;384        *(vu16*)Address = Data;
000020  802e              STRH     r6,[r5,#0]
;;;385        /* Wait for last operation to be completed */
;;;386        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;387    
;;;388        if(status != FLASH_BUSY)
00002a  2c01              CMP      r4,#1
00002c  d006              BEQ      |L16.60|
;;;389        {
;;;390          /* if the program operation is completed, disable the PG Bit */
;;;391          FLASH->CR &= CR_PG_Reset;
00002e  4804              LDR      r0,|L16.64|
000030  6900              LDR      r0,[r0,#0x10]
000032  f64171fe          MOV      r1,#0x1ffe
000036  4008              ANDS     r0,r0,r1
000038  4901              LDR      r1,|L16.64|
00003a  6108              STR      r0,[r1,#0x10]
                  |L16.60|
;;;392        }
;;;393      } 
;;;394      /* Return the Program Status */
;;;395      return status;
00003c  4620              MOV      r0,r4
;;;396    }
00003e  bd70              POP      {r4-r6,pc}
;;;397    
                          ENDP

                  |L16.64|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;408    *******************************************************************************/
;;;409    FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;410    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;411      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;412    
;;;413      /* Check the parameters */
;;;414      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;415    
;;;416      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;417    
;;;418      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L17.68|
;;;419      {
;;;420        /* Authorize the small information block programming */
;;;421        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L17.72|
000016  490d              LDR      r1,|L17.76|
000018  6088              STR      r0,[r1,#8]
;;;422        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L17.80|
00001c  6088              STR      r0,[r1,#8]
;;;423    
;;;424        /* Enables the Option Bytes Programming operation */
;;;425        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;426        *(vu16*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;427        
;;;428        /* Wait for last operation to be completed */
;;;429        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  200f              MOVS     r0,#0xf
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;430    
;;;431        if(status != FLASH_BUSY)
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L17.68|
;;;432        {
;;;433          /* if the program operation is completed, disable the OPTPG Bit */
;;;434          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L17.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L17.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L17.68|
;;;435        }
;;;436      }    
;;;437      /* Return the Option Byte Data Program Status */
;;;438      return status;      
000044  4620              MOV      r0,r4
;;;439    }
000046  bd70              POP      {r4-r6,pc}
;;;440    
                          ENDP

                  |L17.72|
                          DCD      0x45670123
                  |L17.76|
                          DCD      0x40022000
                  |L17.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;309    *******************************************************************************/
;;;310    FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;311    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;312      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;313    
;;;314      /* Check the parameters */
;;;315      assert_param(IS_FLASH_ADDRESS(Address));
;;;316    
;;;317      /* Wait for last operation to be completed */
;;;318      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;319      
;;;320      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d125              BNE      |L18.96|
;;;321      {
;;;322        /* if the previous operation is completed, proceed to program the new first 
;;;323        half word */
;;;324        FLASH->CR |= CR_PG_Set;
000014  4813              LDR      r0,|L18.100|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4911              LDR      r1,|L18.100|
00001e  6108              STR      r0,[r1,#0x10]
;;;325      
;;;326        *(vu16*)Address = (u16)Data;
000020  802e              STRH     r6,[r5,#0]
;;;327    
;;;328        /* Wait for last operation to be completed */
;;;329        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;330     
;;;331        if(status == FLASH_COMPLETE)
00002a  2c04              CMP      r4,#4
00002c  d10f              BNE      |L18.78|
;;;332        {
;;;333          /* if the previous operation is completed, proceed to program the new second 
;;;334          half word */
;;;335          *(vu16*)(Address + 2) = Data >> 16;
00002e  0c30              LSRS     r0,r6,#16
000030  8068              STRH     r0,[r5,#2]
;;;336        
;;;337          /* Wait for last operation to be completed */
;;;338          status = FLASH_WaitForLastOperation(ProgramTimeout);
000032  200f              MOVS     r0,#0xf
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;339            
;;;340          if(status != FLASH_BUSY)
00003a  2c01              CMP      r4,#1
00003c  d010              BEQ      |L18.96|
;;;341          {
;;;342            /* Disable the PG Bit */
;;;343            FLASH->CR &= CR_PG_Reset;
00003e  4809              LDR      r0,|L18.100|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171fe          MOV      r1,#0x1ffe
000046  4008              ANDS     r0,r0,r1
000048  4906              LDR      r1,|L18.100|
00004a  6108              STR      r0,[r1,#0x10]
00004c  e008              B        |L18.96|
                  |L18.78|
;;;344          }
;;;345        }
;;;346        else
;;;347        {
;;;348          if (status != FLASH_BUSY)
00004e  2c01              CMP      r4,#1
000050  d006              BEQ      |L18.96|
;;;349          {
;;;350            /* Disable the PG Bit */
;;;351            FLASH->CR &= CR_PG_Reset;
000052  4804              LDR      r0,|L18.100|
000054  6900              LDR      r0,[r0,#0x10]
000056  f64171fe          MOV      r1,#0x1ffe
00005a  4008              ANDS     r0,r0,r1
00005c  4901              LDR      r1,|L18.100|
00005e  6108              STR      r0,[r1,#0x10]
                  |L18.96|
;;;352          }
;;;353         }
;;;354      }
;;;355      /* Return the Program Status */
;;;356      return status;
000060  4620              MOV      r0,r4
;;;357    }
000062  bd70              POP      {r4-r6,pc}
;;;358    
                          ENDP

                  |L18.100|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;536    *******************************************************************************/
;;;537    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
000002  4605              MOV      r5,r0
;;;539      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;540    
;;;541      /* Check the parameters */
;;;542      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;543    
;;;544      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;545    
;;;546      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L19.152|
;;;547      {
;;;548        /* Authorizes the small information block programming */
;;;549        FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L19.156|
000016  4922              LDR      r1,|L19.160|
000018  6088              STR      r0,[r1,#8]
;;;550        FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L19.164|
00001c  6088              STR      r0,[r1,#8]
;;;551    
;;;552        FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;553        FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;554    
;;;555        /* Wait for last operation to be completed */
;;;556        status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f64070ff          MOV      r0,#0xfff
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;557    
;;;558        if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L19.134|
;;;559        {
;;;560          /* if the erase operation is completed, disable the OPTER Bit */
;;;561          FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L19.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L19.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;562    
;;;563          /* Enable the Option Bytes Programming operation */
;;;564          FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;565    
;;;566          if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L19.98|
;;;567          {
;;;568            OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L19.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L19.104|
                  |L19.98|
;;;569          }
;;;570          else
;;;571          {
;;;572            OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L19.168|
000066  8008              STRH     r0,[r1,#0]
                  |L19.104|
;;;573          }
;;;574    
;;;575          /* Wait for last operation to be completed */
;;;576          status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f64070ff          MOV      r0,#0xfff
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;577        
;;;578          if(status != FLASH_BUSY)
000072  2c01              CMP      r4,#1
000074  d010              BEQ      |L19.152|
;;;579          {
;;;580            /* if the program operation is completed, disable the OPTPG Bit */
;;;581            FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L19.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L19.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L19.152|
                  |L19.134|
;;;582          }
;;;583        }
;;;584        else 
;;;585        {
;;;586          if(status != FLASH_BUSY)
000086  2c01              CMP      r4,#1
000088  d006              BEQ      |L19.152|
;;;587          {
;;;588            /* Disable the OPTER Bit */
;;;589            FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L19.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L19.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L19.152|
;;;590          }
;;;591        }
;;;592      }
;;;593      /* Return the protection operation Status */
;;;594      return status;      
000098  4620              MOV      r0,r4
;;;595    }
00009a  bd70              POP      {r4-r6,pc}
;;;596      	
                          ENDP

                  |L19.156|
                          DCD      0x45670123
                  |L19.160|
                          DCD      0x40022000
                  |L19.164|
                          DCD      0xcdef89ab
                  |L19.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;85     *******************************************************************************/
;;;86     void FLASH_SetLatency(u32 FLASH_Latency)
000000  4905              LDR      r1,|L20.24|
;;;87     {
;;;88       /* Check the parameters */
;;;89       assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;90       
;;;91       /* Sets the Latency value */
;;;92       FLASH->ACR &= ACR_LATENCY_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0010138          AND      r1,r1,#0x38
000008  4a03              LDR      r2,|L20.24|
00000a  6011              STR      r1,[r2,#0]
;;;93       FLASH->ACR |= FLASH_Latency;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;94     }
000014  4770              BX       lr
;;;95     
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;143    *******************************************************************************/
;;;144    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L21.12|
;;;145    {
;;;146      /* Authorize the FPEC Access */
;;;147      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L21.16|
000004  6048              STR      r0,[r1,#4]
;;;148      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L21.20|
000008  6048              STR      r0,[r1,#4]
;;;149    }
00000a  4770              BX       lr
;;;150    
                          ENDP

                  |L21.12|
                          DCD      0x45670123
                  |L21.16|
                          DCD      0x40022000
                  |L21.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;617    *******************************************************************************/
;;;618    FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;619    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;620      FLASH_Status status = FLASH_COMPLETE; 
00000a  2404              MOVS     r4,#4
;;;621    
;;;622      /* Check the parameters */
;;;623      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;624      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;625      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;626    
;;;627      /* Authorize the small information block programming */
;;;628      FLASH->OPTKEYR = FLASH_KEY1;
00000c  4814              LDR      r0,|L22.96|
00000e  4915              LDR      r1,|L22.100|
000010  6088              STR      r0,[r1,#8]
;;;629      FLASH->OPTKEYR = FLASH_KEY2;
000012  4815              LDR      r0,|L22.104|
000014  6088              STR      r0,[r1,#8]
;;;630      
;;;631      /* Wait for last operation to be completed */
;;;632      status = FLASH_WaitForLastOperation(ProgramTimeout);
000016  200f              MOVS     r0,#0xf
000018  f7fffffe          BL       FLASH_WaitForLastOperation
00001c  4604              MOV      r4,r0
;;;633      
;;;634      if(status == FLASH_COMPLETE)
00001e  2c04              CMP      r4,#4
000020  d11a              BNE      |L22.88|
;;;635      {  
;;;636        /* Enable the Option Bytes Programming operation */
;;;637        FLASH->CR |= CR_OPTPG_Set; 
000022  4810              LDR      r0,|L22.100|
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400010          ORR      r0,r0,#0x10
00002a  490e              LDR      r1,|L22.100|
00002c  6108              STR      r0,[r1,#0x10]
;;;638               
;;;639        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
00002e  ea470005          ORR      r0,r7,r5
000032  4330              ORRS     r0,r0,r6
000034  f04000f8          ORR      r0,r0,#0xf8
000038  490c              LDR      r1,|L22.108|
00003a  8008              STRH     r0,[r1,#0]
;;;640      
;;;641        /* Wait for last operation to be completed */
;;;642        status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  f04f000f          MOV      r0,#0xf
000040  f7fffffe          BL       FLASH_WaitForLastOperation
000044  4604              MOV      r4,r0
;;;643    
;;;644        if(status != FLASH_BUSY)
000046  2c01              CMP      r4,#1
000048  d006              BEQ      |L22.88|
;;;645        {
;;;646          /* if the program operation is completed, disable the OPTPG Bit */
;;;647          FLASH->CR &= CR_OPTPG_Reset;
00004a  4806              LDR      r0,|L22.100|
00004c  6900              LDR      r0,[r0,#0x10]
00004e  f64171ef          MOV      r1,#0x1fef
000052  4008              ANDS     r0,r0,r1
000054  4903              LDR      r1,|L22.100|
000056  6108              STR      r0,[r1,#0x10]
                  |L22.88|
;;;648        }
;;;649      }    
;;;650      /* Return the Option Byte program Status */
;;;651      return status;
000058  4620              MOV      r0,r4
;;;652    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;653    
                          ENDP

00005e  0000              DCW      0x0000
                  |L22.96|
                          DCD      0x45670123
                  |L22.100|
                          DCD      0x40022000
                  |L22.104|
                          DCD      0xcdef89ab
                  |L22.108|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;869    *******************************************************************************/
;;;870    FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;871    { 
000002  4604              MOV      r4,r0
;;;872      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;873       
;;;874      /* Check for the Flash Status */
;;;875      status = FLASH_GetStatus();
000006  f7fffffe          BL       FLASH_GetStatus
00000a  4605              MOV      r5,r0
;;;876    
;;;877      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;878      while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e005              B        |L23.26|
                  |L23.14|
;;;879      {
;;;880        delay();
00000e  f7fffffe          BL       delay
;;;881        status = FLASH_GetStatus();
000012  f7fffffe          BL       FLASH_GetStatus
000016  4605              MOV      r5,r0
;;;882        Timeout--;
000018  1e64              SUBS     r4,r4,#1
                  |L23.26|
00001a  2d01              CMP      r5,#1                 ;878
00001c  d101              BNE      |L23.34|
00001e  2c00              CMP      r4,#0                 ;878
000020  d1f5              BNE      |L23.14|
                  |L23.34|
;;;883      }
;;;884    
;;;885      if(Timeout == 0x00 )
000022  b904              CBNZ     r4,|L23.38|
;;;886      {
;;;887        status = FLASH_TIMEOUT;
000024  2505              MOVS     r5,#5
                  |L23.38|
;;;888      }
;;;889    
;;;890      /* Return the operation status */
;;;891      return status;
000026  4628              MOV      r0,r5
;;;892    }
000028  bd70              POP      {r4-r6,pc}
;;;893    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;900    *******************************************************************************/
;;;901    static void delay(void)
000000  2000              MOVS     r0,#0
;;;902    {
;;;903      vu32 i = 0;
;;;904    
;;;905      for(i = 0xFF; i != 0; i--)
000002  20ff              MOVS     r0,#0xff
000004  e000              B        |L24.8|
                  |L24.6|
000006  1e40              SUBS     r0,r0,#1
                  |L24.8|
000008  2800              CMP      r0,#0
00000a  d1fc              BNE      |L24.6|
;;;906      {
;;;907      }
;;;908    }
00000c  4770              BX       lr
;;;909    #endif
                          ENDP

