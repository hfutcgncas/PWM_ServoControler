; generated by ARM C/C++ Compiler, 4.1 [Build 567]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_nvic.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_nvic.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\source\wlib\œµÕ≥ ±÷”≈‰÷√ -I.\source\wlib\delay -I..\uvsion -I"D:\Program Files\keil4.14\ARM\INC" -I"D:\Program Files\keil4.14\ARM\INC\ST\STM32F10x" --omf_browse=.\obj\stm32f10x_nvic.crf source\FWLib\src\stm32f10x_nvic.c]
                          THUMB

                          AREA ||i.NVIC_BASEPRICONFIG||, CODE, READONLY, ALIGN=1

                  NVIC_BASEPRICONFIG PROC
;;;233    *******************************************************************************/
;;;234    void NVIC_BASEPRICONFIG(u32 NewPriority)
000000  b510              PUSH     {r4,lr}
;;;235    {
000002  4604              MOV      r4,r0
;;;236      /* Check the parameters */
;;;237      assert_param(IS_NVIC_BASE_PRI(NewPriority));
;;;238      
;;;239      __BASEPRICONFIG(NewPriority << 0x04);
000004  0120              LSLS     r0,r4,#4
000006  f7fffffe          BL       __BASEPRICONFIG
;;;240    }
00000a  bd10              POP      {r4,pc}
;;;241    
                          ENDP


                          AREA ||i.NVIC_ClearIRQChannelPendingBit||, CODE, READONLY, ALIGN=2

                  NVIC_ClearIRQChannelPendingBit PROC
;;;316    *******************************************************************************/
;;;317    void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
000000  f000021f          AND      r2,r0,#0x1f
;;;318    {
;;;319      /* Check the parameters */
;;;320      assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
;;;321      
;;;322      NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L2.20|
00000a  1143              ASRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;323    }
000010  4770              BX       lr
;;;324    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0xe000e280

                          AREA ||i.NVIC_ClearSystemHandlerPendingBit||, CODE, READONLY, ALIGN=2

                  NVIC_ClearSystemHandlerPendingBit PROC
;;;613    *******************************************************************************/
;;;614    void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
000000  b510              PUSH     {r4,lr}
;;;615    {
;;;616      u32 tmp = 0x00;
000002  2100              MOVS     r1,#0
;;;617    
;;;618      /* Check the parameters */
;;;619      assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
;;;620      
;;;621      /* Get the System Handler pending bit position */
;;;622      tmp = SystemHandler & (u32)0x1F;
000004  f000011f          AND      r1,r0,#0x1f
;;;623      /* Clear the corresponding System Handler pending bit */
;;;624      SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
000008  4a07              LDR      r2,|L3.40|
00000a  6812              LDR      r2,[r2,#0]
00000c  f1a10301          SUB      r3,r1,#1
000010  f04f0401          MOV      r4,#1
000014  fa04f403          LSL      r4,r4,r3
000018  ea420204          ORR      r2,r2,r4
00001c  f04f23e0          MOV      r3,#0xe000e000
000020  f8c32d04          STR      r2,[r3,#0xd04]
;;;625    }
000024  bd10              POP      {r4,pc}
;;;626    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0xe000ed04

                          AREA ||i.NVIC_DeInit||, CODE, READONLY, ALIGN=2

                  NVIC_DeInit PROC
;;;35     *******************************************************************************/
;;;36     void NVIC_DeInit(void)
000000  2000              MOVS     r0,#0
;;;37     {
;;;38       u32 index = 0;
;;;39       
;;;40       NVIC->ICER[0] = 0xFFFFFFFF;
000002  1e41              SUBS     r1,r0,#1
000004  4a0d              LDR      r2,|L4.60|
000006  6011              STR      r1,[r2,#0]
;;;41       NVIC->ICER[1] = 0x0FFFFFFF;
000008  f06f4270          MVN      r2,#0xf0000000
00000c  490c              LDR      r1,|L4.64|
00000e  f8c12084          STR      r2,[r1,#0x84]
;;;42       NVIC->ICPR[0] = 0xFFFFFFFF;
000012  f04f31ff          MOV      r1,#0xffffffff
000016  f04f22e0          MOV      r2,#0xe000e000
00001a  f8c21280          STR      r1,[r2,#0x280]
;;;43       NVIC->ICPR[1] = 0x0FFFFFFF;
00001e  f06f4270          MVN      r2,#0xf0000000
000022  4908              LDR      r1,|L4.68|
000024  600a              STR      r2,[r1,#0]
;;;44       
;;;45       for(index = 0; index < 0x0F; index++)
000026  bf00              NOP      
000028  e004              B        |L4.52|
                  |L4.42|
;;;46       {
;;;47          NVIC->IPR[index] = 0x00000000;
00002a  2200              MOVS     r2,#0
00002c  4906              LDR      r1,|L4.72|
00002e  f8412020          STR      r2,[r1,r0,LSL #2]
000032  1c40              ADDS     r0,r0,#1              ;45
                  |L4.52|
000034  280f              CMP      r0,#0xf               ;45
000036  d3f8              BCC      |L4.42|
;;;48       } 
;;;49     }
000038  4770              BX       lr
;;;50     
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      0xe000e180
                  |L4.64|
                          DCD      0xe000e100
                  |L4.68|
                          DCD      0xe000e284
                  |L4.72|
                          DCD      0xe000e400

                          AREA ||i.NVIC_GenerateCoreReset||, CODE, READONLY, ALIGN=2

                  NVIC_GenerateCoreReset PROC
;;;420    *******************************************************************************/
;;;421    void NVIC_GenerateCoreReset(void)
000000  4801              LDR      r0,|L5.8|
;;;422    {
;;;423      SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
000002  4902              LDR      r1,|L5.12|
000004  6008              STR      r0,[r1,#0]
;;;424    }
000006  4770              BX       lr
;;;425    
                          ENDP

                  |L5.8|
                          DCD      0x05fa0001
                  |L5.12|
                          DCD      0xe000ed0c

                          AREA ||i.NVIC_GenerateSystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_GenerateSystemReset PROC
;;;408    *******************************************************************************/
;;;409    void NVIC_GenerateSystemReset(void)
000000  4801              LDR      r0,|L6.8|
;;;410    {
;;;411      SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
000002  4902              LDR      r1,|L6.12|
000004  6008              STR      r0,[r1,#0]
;;;412    }
000006  4770              BX       lr
;;;413    
                          ENDP

                  |L6.8|
                          DCD      0x05fa0004
                  |L6.12|
                          DCD      0xe000ed0c

                          AREA ||i.NVIC_GetBASEPRI||, CODE, READONLY, ALIGN=1

                  NVIC_GetBASEPRI PROC
;;;248    *******************************************************************************/
;;;249    u32 NVIC_GetBASEPRI(void)
000000  b510              PUSH     {r4,lr}
;;;250    {
;;;251      return (__GetBASEPRI());
000002  f7fffffe          BL       __GetBASEPRI
;;;252    }
000006  bd10              POP      {r4,pc}
;;;253    
                          ENDP


                          AREA ||i.NVIC_GetCPUID||, CODE, READONLY, ALIGN=2

                  NVIC_GetCPUID PROC
;;;374    *******************************************************************************/
;;;375    u32 NVIC_GetCPUID(void)
000000  4801              LDR      r0,|L8.8|
;;;376    {
;;;377      return (SCB->CPUID);
000002  6800              LDR      r0,[r0,#0]
;;;378    }
000004  4770              BX       lr
;;;379    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0xe000ed00

                          AREA ||i.NVIC_GetCurrentActiveHandler||, CODE, READONLY, ALIGN=2

                  NVIC_GetCurrentActiveHandler PROC
;;;332    *******************************************************************************/
;;;333    u16 NVIC_GetCurrentActiveHandler(void)
000000  4802              LDR      r0,|L9.12|
;;;334    {
;;;335      return ((u16)(SCB->ICSR & (u32)0x3FF));
000002  6800              LDR      r0,[r0,#0]
000004  f3c00009          UBFX     r0,r0,#0,#10
;;;336    }
000008  4770              BX       lr
;;;337    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0xe000ed04

                          AREA ||i.NVIC_GetCurrentPendingIRQChannel||, CODE, READONLY, ALIGN=2

                  NVIC_GetCurrentPendingIRQChannel PROC
;;;260    *******************************************************************************/
;;;261    u16 NVIC_GetCurrentPendingIRQChannel(void)
000000  4802              LDR      r0,|L10.12|
;;;262    {
;;;263      return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
000002  6800              LDR      r0,[r0,#0]
000004  f3c03009          UBFX     r0,r0,#12,#10
;;;264    }
000008  4770              BX       lr
;;;265    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0xe000ed04

                          AREA ||i.NVIC_GetFaultAddress||, CODE, READONLY, ALIGN=2

                  NVIC_GetFaultAddress PROC
;;;729    *******************************************************************************/
;;;730    u32 NVIC_GetFaultAddress(u32 SystemHandler)
000000  4601              MOV      r1,r0
;;;731    {
;;;732      u32 faultaddress = 0x00;
000002  2000              MOVS     r0,#0
;;;733      u32 tmp = 0x00;
000004  2200              MOVS     r2,#0
;;;734    
;;;735      /* Check the parameters */
;;;736      assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
;;;737      
;;;738      tmp = (SystemHandler >> 0x16) & (u32)0x01;
000006  f3c15280          UBFX     r2,r1,#22,#1
;;;739    
;;;740      if (tmp == 0x00)
00000a  b912              CBNZ     r2,|L11.18|
;;;741      {
;;;742        faultaddress = SCB->MMFAR;
00000c  4b02              LDR      r3,|L11.24|
00000e  6818              LDR      r0,[r3,#0]
000010  e001              B        |L11.22|
                  |L11.18|
;;;743      }
;;;744      else
;;;745      {
;;;746        faultaddress = SCB->BFAR;
000012  4b02              LDR      r3,|L11.28|
000014  6818              LDR      r0,[r3,#0]
                  |L11.22|
;;;747      }
;;;748      return faultaddress;
;;;749    }
000016  4770              BX       lr
;;;750    
                          ENDP

                  |L11.24|
                          DCD      0xe000ed34
                  |L11.28|
                          DCD      0xe000ed38

                          AREA ||i.NVIC_GetFaultHandlerSources||, CODE, READONLY, ALIGN=2

                  NVIC_GetFaultHandlerSources PROC
;;;683    *******************************************************************************/
;;;684    u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
000000  b530              PUSH     {r4,r5,lr}
;;;685    {
000002  4601              MOV      r1,r0
;;;686      u32 faultsources = 0x00;
000004  2000              MOVS     r0,#0
;;;687      u32 tmpreg = 0x00, tmppos = 0x00;
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;688    
;;;689      /* Check the parameters */
;;;690      assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
;;;691      
;;;692      tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
00000a  f3c14281          UBFX     r2,r1,#18,#2
;;;693      tmppos = (SystemHandler >> 0x14) & (u32)0x03;
00000e  f3c15301          UBFX     r3,r1,#20,#2
;;;694    
;;;695      if (tmpreg == 0x00)
000012  b912              CBNZ     r2,|L12.26|
;;;696      {
;;;697        faultsources = SCB->HFSR;
000014  4c0a              LDR      r4,|L12.64|
000016  6820              LDR      r0,[r4,#0]
000018  e010              B        |L12.60|
                  |L12.26|
;;;698      }
;;;699      else if (tmpreg == 0x01)
00001a  2a01              CMP      r2,#1
00001c  d10c              BNE      |L12.56|
;;;700      {
;;;701        faultsources = SCB->CFSR >> (tmppos * 0x08);
00001e  4c09              LDR      r4,|L12.68|
000020  6824              LDR      r4,[r4,#0]
000022  ea4f05c3          LSL      r5,r3,#3
000026  fa24f005          LSR      r0,r4,r5
;;;702        if (tmppos != 0x02)
00002a  2b02              CMP      r3,#2
00002c  d002              BEQ      |L12.52|
;;;703        {
;;;704          faultsources &= (u32)0x0F;
00002e  f000000f          AND      r0,r0,#0xf
000032  e003              B        |L12.60|
                  |L12.52|
;;;705        }
;;;706        else
;;;707        {
;;;708          faultsources &= (u32)0xFF;
000034  b2c0              UXTB     r0,r0
000036  e001              B        |L12.60|
                  |L12.56|
;;;709        }
;;;710      }
;;;711      else
;;;712      {
;;;713        faultsources = SCB->DFSR;
000038  4c03              LDR      r4,|L12.72|
00003a  6820              LDR      r0,[r4,#0]
                  |L12.60|
;;;714      }
;;;715      return faultsources;
;;;716    }
00003c  bd30              POP      {r4,r5,pc}
;;;717    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      0xe000ed2c
                  |L12.68|
                          DCD      0xe000ed28
                  |L12.72|
                          DCD      0xe000ed30

                          AREA ||i.NVIC_GetIRQChannelActiveBitStatus||, CODE, READONLY, ALIGN=2

                  NVIC_GetIRQChannelActiveBitStatus PROC
;;;345    *******************************************************************************/
;;;346    ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
000000  b510              PUSH     {r4,lr}
;;;347    {
000002  4601              MOV      r1,r0
;;;348      ITStatus activeirqstatus = RESET;
000004  2000              MOVS     r0,#0
;;;349      u32 tmp = 0x00;
000006  2200              MOVS     r2,#0
;;;350    
;;;351      /* Check the parameters */
;;;352      assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
;;;353      
;;;354      tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
000008  f001041f          AND      r4,r1,#0x1f
00000c  2301              MOVS     r3,#1
00000e  fa03f204          LSL      r2,r3,r4
;;;355    
;;;356      if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
000012  4b05              LDR      r3,|L13.40|
000014  114c              ASRS     r4,r1,#5
000016  f8533024          LDR      r3,[r3,r4,LSL #2]
00001a  4013              ANDS     r3,r3,r2
00001c  4293              CMP      r3,r2
00001e  d101              BNE      |L13.36|
;;;357      {
;;;358        activeirqstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L13.38|
                  |L13.36|
;;;359      }
;;;360      else
;;;361      {
;;;362        activeirqstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L13.38|
;;;363      }
;;;364      return activeirqstatus;
;;;365    }
000026  bd10              POP      {r4,pc}
;;;366    
                          ENDP

                  |L13.40|
                          DCD      0xe000e300

                          AREA ||i.NVIC_GetIRQChannelPendingBitStatus||, CODE, READONLY, ALIGN=2

                  NVIC_GetIRQChannelPendingBitStatus PROC
;;;273    *******************************************************************************/
;;;274    ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
000000  b510              PUSH     {r4,lr}
;;;275    {
000002  4601              MOV      r1,r0
;;;276      ITStatus pendingirqstatus = RESET;
000004  2000              MOVS     r0,#0
;;;277      u32 tmp = 0x00;
000006  2200              MOVS     r2,#0
;;;278      
;;;279      /* Check the parameters */
;;;280      assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
;;;281      
;;;282      tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
000008  f001041f          AND      r4,r1,#0x1f
00000c  2301              MOVS     r3,#1
00000e  fa03f204          LSL      r2,r3,r4
;;;283    
;;;284      if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
000012  4b05              LDR      r3,|L14.40|
000014  114c              ASRS     r4,r1,#5
000016  f8533024          LDR      r3,[r3,r4,LSL #2]
00001a  4013              ANDS     r3,r3,r2
00001c  4293              CMP      r3,r2
00001e  d101              BNE      |L14.36|
;;;285      {
;;;286        pendingirqstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L14.38|
                  |L14.36|
;;;287      }
;;;288      else
;;;289      {
;;;290        pendingirqstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L14.38|
;;;291      }
;;;292      return pendingirqstatus;
;;;293    }
000026  bd10              POP      {r4,pc}
;;;294    
                          ENDP

                  |L14.40|
                          DCD      0xe000e200

                          AREA ||i.NVIC_GetSystemHandlerActiveBitStatus||, CODE, READONLY, ALIGN=2

                  NVIC_GetSystemHandlerActiveBitStatus PROC
;;;643    *******************************************************************************/
;;;644    ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
000000  b510              PUSH     {r4,lr}
;;;645    {
000002  4602              MOV      r2,r0
;;;646      ITStatus bitstatus  = RESET;
000004  2000              MOVS     r0,#0
;;;647    
;;;648      u32 tmp = 0x00, tmppos = 0x00;
000006  2300              MOVS     r3,#0
000008  2100              MOVS     r1,#0
;;;649    
;;;650      /* Check the parameters */
;;;651      assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
;;;652      
;;;653      tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
00000a  f3c23183          UBFX     r1,r2,#14,#4
;;;654    
;;;655      tmppos = (u32)0x01 << tmppos;
00000e  2401              MOVS     r4,#1
000010  fa04f101          LSL      r1,r4,r1
;;;656    
;;;657      tmp = SCB->SHCSR & tmppos;
000014  4c04              LDR      r4,|L15.40|
000016  6824              LDR      r4,[r4,#0]
000018  ea040301          AND      r3,r4,r1
;;;658    
;;;659      if (tmp == tmppos)
00001c  428b              CMP      r3,r1
00001e  d101              BNE      |L15.36|
;;;660      {
;;;661        bitstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L15.38|
                  |L15.36|
;;;662      }
;;;663      else
;;;664      {
;;;665        bitstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L15.38|
;;;666      }
;;;667      return bitstatus;
;;;668    }
000026  bd10              POP      {r4,pc}
;;;669    
                          ENDP

                  |L15.40|
                          DCD      0xe000ed24

                          AREA ||i.NVIC_GetSystemHandlerPendingBitStatus||, CODE, READONLY, ALIGN=2

                  NVIC_GetSystemHandlerPendingBitStatus PROC
;;;551    *******************************************************************************/
;;;552    ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
000000  b510              PUSH     {r4,lr}
;;;553    {
000002  4602              MOV      r2,r0
;;;554      ITStatus bitstatus  = RESET;
000004  2000              MOVS     r0,#0
;;;555      u32 tmp = 0x00, tmppos = 0x00;
000006  2300              MOVS     r3,#0
000008  2100              MOVS     r1,#0
;;;556    
;;;557      /* Check the parameters */
;;;558      assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
;;;559      
;;;560      tmppos = (SystemHandler >> 0x0A);
00000a  0a91              LSRS     r1,r2,#10
;;;561      tmppos &= (u32)0x0F;
00000c  f001010f          AND      r1,r1,#0xf
;;;562    
;;;563      tmppos = (u32)0x01 << tmppos;
000010  2401              MOVS     r4,#1
000012  fa04f101          LSL      r1,r4,r1
;;;564    
;;;565      tmp = SCB->SHCSR & tmppos;
000016  4c05              LDR      r4,|L16.44|
000018  6824              LDR      r4,[r4,#0]
00001a  ea040301          AND      r3,r4,r1
;;;566    
;;;567      if (tmp == tmppos)
00001e  428b              CMP      r3,r1
000020  d101              BNE      |L16.38|
;;;568      {
;;;569        bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L16.40|
                  |L16.38|
;;;570      }
;;;571      else
;;;572      {
;;;573        bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L16.40|
;;;574      }
;;;575      return bitstatus;
;;;576    }
000028  bd10              POP      {r4,pc}
;;;577    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      0xe000ed24

                          AREA ||i.NVIC_Init||, CODE, READONLY, ALIGN=2

                  NVIC_Init PROC
;;;115    *******************************************************************************/
;;;116    void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;117    {
;;;118      u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;119      u32 tmppre = 0, tmpsub = 0x0F;
000008  2500              MOVS     r5,#0
00000a  240f              MOVS     r4,#0xf
;;;120    
;;;121      /* Check the parameters */
;;;122      assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
;;;123      assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
;;;124      assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
;;;125      assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
;;;126        
;;;127      if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
00000c  78c6              LDRB     r6,[r0,#3]
00000e  2e00              CMP      r6,#0
000010  d048              BEQ      |L17.164|
;;;128      {
;;;129        /* Compute the Corresponding IRQ Priority --------------------------------*/    
;;;130        tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
000012  4e2b              LDR      r6,|L17.192|
000014  6836              LDR      r6,[r6,#0]
000016  f40666e0          AND      r6,r6,#0x700
00001a  f5c666e0          RSB      r6,r6,#0x700
00001e  ea4f2116          LSR      r1,r6,#8
;;;131        tmppre = (0x4 - tmppriority);
000022  f1c10504          RSB      r5,r1,#4
;;;132        tmpsub = tmpsub >> tmppriority;
000026  fa24f401          LSR      r4,r4,r1
;;;133        
;;;134        tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
00002a  7846              LDRB     r6,[r0,#1]
00002c  fa06f105          LSL      r1,r6,r5
;;;135        tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
000030  7886              LDRB     r6,[r0,#2]
000032  ea060604          AND      r6,r6,r4
000036  ea460101          ORR      r1,r6,r1
;;;136    
;;;137        tmppriority = tmppriority << 0x04;
00003a  ea4f1101          LSL      r1,r1,#4
;;;138        tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
00003e  7806              LDRB     r6,[r0,#0]
000040  ea4f7686          LSL      r6,r6,#30
000044  ea4f66d6          LSR      r6,r6,#27
000048  fa01f106          LSL      r1,r1,r6
;;;139        
;;;140        tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
00004c  4e1d              LDR      r6,|L17.196|
00004e  7807              LDRB     r7,[r0,#0]
000050  ea4f07a7          ASR      r7,r7,#2
000054  f8562027          LDR      r2,[r6,r7,LSL #2]
;;;141        tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
000058  7806              LDRB     r6,[r0,#0]
00005a  ea4f7686          LSL      r6,r6,#30
00005e  ea4f67d6          LSR      r7,r6,#27
000062  f04f06ff          MOV      r6,#0xff
000066  fa06f307          LSL      r3,r6,r7
;;;142        tmpreg &= ~tmpmask;
00006a  ea220203          BIC      r2,r2,r3
;;;143        tmppriority &= tmpmask;  
00006e  ea010103          AND      r1,r1,r3
;;;144        tmpreg |= tmppriority;
000072  ea420201          ORR      r2,r2,r1
;;;145    
;;;146        NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
000076  4e13              LDR      r6,|L17.196|
000078  7807              LDRB     r7,[r0,#0]
00007a  ea4f07a7          ASR      r7,r7,#2
00007e  f8462027          STR      r2,[r6,r7,LSL #2]
;;;147        
;;;148        /* Enable the Selected IRQ Channels --------------------------------------*/
;;;149        NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
000082  7806              LDRB     r6,[r0,#0]
000084  f006071f          AND      r7,r6,#0x1f
000088  f04f0601          MOV      r6,#1
00008c  fa06f607          LSL      r6,r6,r7
000090  7807              LDRB     r7,[r0,#0]
000092  ea4f1767          ASR      r7,r7,#5
000096  f04f2ce0          MOV      r12,#0xe000e000
00009a  eb0c0787          ADD      r7,r12,r7,LSL #2
00009e  f8c76100          STR      r6,[r7,#0x100]
0000a2  e00b              B        |L17.188|
                  |L17.164|
;;;150          (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
;;;151      }
;;;152      else
;;;153      {
;;;154        /* Disable the Selected IRQ Channels -------------------------------------*/
;;;155        NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
0000a4  7806              LDRB     r6,[r0,#0]
0000a6  f006071f          AND      r7,r6,#0x1f
0000aa  2601              MOVS     r6,#1
0000ac  40be              LSLS     r6,r6,r7
0000ae  4f06              LDR      r7,|L17.200|
0000b0  f890c000          LDRB     r12,[r0,#0]
0000b4  ea4f1c6c          ASR      r12,r12,#5
0000b8  f847602c          STR      r6,[r7,r12,LSL #2]
                  |L17.188|
;;;156          (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
;;;157      }
;;;158    }
0000bc  bdf0              POP      {r4-r7,pc}
;;;159    
                          ENDP

0000be  0000              DCW      0x0000
                  |L17.192|
                          DCD      0xe000ed0c
                  |L17.196|
                          DCD      0xe000e400
                  |L17.200|
                          DCD      0xe000e180

                          AREA ||i.NVIC_PriorityGroupConfig||, CODE, READONLY, ALIGN=2

                  NVIC_PriorityGroupConfig PROC
;;;96     *******************************************************************************/
;;;97     void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
000000  4902              LDR      r1,|L18.12|
;;;98     {
;;;99       /* Check the parameters */
;;;100      assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
;;;101      
;;;102      /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
;;;103      SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
000002  4301              ORRS     r1,r1,r0
000004  4a02              LDR      r2,|L18.16|
000006  6011              STR      r1,[r2,#0]
;;;104    }
000008  4770              BX       lr
;;;105    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x05fa0000
                  |L18.16|
                          DCD      0xe000ed0c

                          AREA ||i.NVIC_RESETFAULTMASK||, CODE, READONLY, ALIGN=1

                  NVIC_RESETFAULTMASK PROC
;;;219    *******************************************************************************/
;;;220    void NVIC_RESETFAULTMASK(void)
000000  b510              PUSH     {r4,lr}
;;;221    {
;;;222      __RESETFAULTMASK();
000002  f7fffffe          BL       __RESETFAULTMASK
;;;223    }
000006  bd10              POP      {r4,pc}
;;;224    
                          ENDP


                          AREA ||i.NVIC_RESETPRIMASK||, CODE, READONLY, ALIGN=1

                  NVIC_RESETPRIMASK PROC
;;;195    *******************************************************************************/
;;;196    void NVIC_RESETPRIMASK(void)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198      __RESETPRIMASK();
000002  f7fffffe          BL       __RESETPRIMASK
;;;199    }
000006  bd10              POP      {r4,pc}
;;;200    
                          ENDP


                          AREA ||i.NVIC_SCBDeInit||, CODE, READONLY, ALIGN=2

                  NVIC_SCBDeInit PROC
;;;58     *******************************************************************************/
;;;59     void NVIC_SCBDeInit(void)
000000  2000              MOVS     r0,#0
;;;60     {
;;;61       u32 index = 0x00;
;;;62       
;;;63       SCB->ICSR = 0x0A000000;
000002  f04f6120          MOV      r1,#0xa000000
000006  4a15              LDR      r2,|L21.92|
000008  6011              STR      r1,[r2,#0]
;;;64       SCB->VTOR = 0x00000000;
00000a  4601              MOV      r1,r0
00000c  f04f22e0          MOV      r2,#0xe000e000
000010  f8c21d08          STR      r1,[r2,#0xd08]
;;;65       SCB->AIRCR = AIRCR_VECTKEY_MASK;
000014  4912              LDR      r1,|L21.96|
000016  4a13              LDR      r2,|L21.100|
000018  6011              STR      r1,[r2,#0]
;;;66       SCB->SCR = 0x00000000;
00001a  4601              MOV      r1,r0
00001c  f1020204          ADD      r2,r2,#4
000020  6011              STR      r1,[r2,#0]
;;;67       SCB->CCR = 0x00000000;
000022  f1020204          ADD      r2,r2,#4
000026  6011              STR      r1,[r2,#0]
;;;68       for(index = 0; index < 0x03; index++)
000028  bf00              NOP      
00002a  e005              B        |L21.56|
                  |L21.44|
;;;69       {
;;;70          SCB->SHPR[index] = 0;
00002c  2200              MOVS     r2,#0
00002e  490d              LDR      r1,|L21.100|
000030  310c              ADDS     r1,r1,#0xc
000032  f8412020          STR      r2,[r1,r0,LSL #2]
000036  1c40              ADDS     r0,r0,#1              ;68
                  |L21.56|
000038  2803              CMP      r0,#3                 ;68
00003a  d3f7              BCC      |L21.44|
;;;71       }
;;;72       SCB->SHCSR = 0x00000000;
00003c  2100              MOVS     r1,#0
00003e  4a0a              LDR      r2,|L21.104|
000040  6011              STR      r1,[r2,#0]
;;;73       SCB->CFSR = 0xFFFFFFFF;
000042  f04f31ff          MOV      r1,#0xffffffff
000046  f04f22e0          MOV      r2,#0xe000e000
00004a  f8c21d28          STR      r1,[r2,#0xd28]
;;;74       SCB->HFSR = 0xFFFFFFFF;
00004e  4a07              LDR      r2,|L21.108|
000050  6011              STR      r1,[r2,#0]
;;;75       SCB->DFSR = 0xFFFFFFFF;
000052  f04f22e0          MOV      r2,#0xe000e000
000056  f8c21d30          STR      r1,[r2,#0xd30]
;;;76     }
00005a  4770              BX       lr
;;;77     
                          ENDP

                  |L21.92|
                          DCD      0xe000ed04
                  |L21.96|
                          DCD      0x05fa0000
                  |L21.100|
                          DCD      0xe000ed0c
                  |L21.104|
                          DCD      0xe000ed24
                  |L21.108|
                          DCD      0xe000ed2c

                          AREA ||i.NVIC_SETFAULTMASK||, CODE, READONLY, ALIGN=1

                  NVIC_SETFAULTMASK PROC
;;;207    *******************************************************************************/
;;;208    void NVIC_SETFAULTMASK(void)
000000  b510              PUSH     {r4,lr}
;;;209    {
;;;210      __SETFAULTMASK();
000002  f7fffffe          BL       __SETFAULTMASK
;;;211    }
000006  bd10              POP      {r4,pc}
;;;212    
                          ENDP


                          AREA ||i.NVIC_SETPRIMASK||, CODE, READONLY, ALIGN=1

                  NVIC_SETPRIMASK PROC
;;;183    *******************************************************************************/
;;;184    void NVIC_SETPRIMASK(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186      __SETPRIMASK();
000002  f7fffffe          BL       __SETPRIMASK
;;;187    }
000006  bd10              POP      {r4,pc}
;;;188    
                          ENDP


                          AREA ||i.NVIC_SetIRQChannelPendingBit||, CODE, READONLY, ALIGN=2

                  NVIC_SetIRQChannelPendingBit PROC
;;;301    *******************************************************************************/
;;;302    void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
000000  4901              LDR      r1,|L24.8|
;;;303    {
;;;304      /* Check the parameters */
;;;305      assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
;;;306      
;;;307      *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
000002  6008              STR      r0,[r1,#0]
;;;308    }
000004  4770              BX       lr
;;;309    
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      0xe000ef00

                          AREA ||i.NVIC_SetSystemHandlerPendingBit||, CODE, READONLY, ALIGN=2

                  NVIC_SetSystemHandlerPendingBit PROC
;;;589    *******************************************************************************/
;;;590    void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
000000  2100              MOVS     r1,#0
;;;591    {
;;;592      u32 tmp = 0x00;
;;;593    
;;;594      /* Check the parameters */
;;;595      assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
;;;596      
;;;597      /* Get the System Handler pending bit position */
;;;598      tmp = SystemHandler & (u32)0x1F;
000002  f000011f          AND      r1,r0,#0x1f
;;;599      /* Set the corresponding System Handler pending bit */
;;;600      SCB->ICSR |= ((u32)0x01 << tmp);
000006  4a06              LDR      r2,|L25.32|
000008  6812              LDR      r2,[r2,#0]
00000a  f04f0301          MOV      r3,#1
00000e  fa03f301          LSL      r3,r3,r1
000012  ea420203          ORR      r2,r2,r3
000016  f04f23e0          MOV      r3,#0xe000e000
00001a  f8c32d04          STR      r2,[r3,#0xd04]
;;;601    }
00001e  4770              BX       lr
;;;602    
                          ENDP

                  |L25.32|
                          DCD      0xe000ed04

                          AREA ||i.NVIC_SetVectorTable||, CODE, READONLY, ALIGN=2

                  NVIC_SetVectorTable PROC
;;;392    *******************************************************************************/
;;;393    void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
000000  4a02              LDR      r2,|L26.12|
;;;394    { 
;;;395      /* Check the parameters */
;;;396      assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
;;;397      assert_param(IS_NVIC_OFFSET(Offset));  
;;;398       
;;;399      SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
000002  400a              ANDS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  4b02              LDR      r3,|L26.16|
000008  601a              STR      r2,[r3,#0]
;;;400    }
00000a  4770              BX       lr
;;;401    
                          ENDP

                  |L26.12|
                          DCD      0x1fffff80
                  |L26.16|
                          DCD      0xe000ed08

                          AREA ||i.NVIC_StructInit||, CODE, READONLY, ALIGN=1

                  NVIC_StructInit PROC
;;;167    *******************************************************************************/
;;;168    void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
000000  2100              MOVS     r1,#0
;;;169    {
;;;170      /* NVIC_InitStruct members default value */
;;;171      NVIC_InitStruct->NVIC_IRQChannel = 0x00;
000002  7001              STRB     r1,[r0,#0]
;;;172      NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
000004  7041              STRB     r1,[r0,#1]
;;;173      NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
000006  7081              STRB     r1,[r0,#2]
;;;174      NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
000008  70c1              STRB     r1,[r0,#3]
;;;175    }
00000a  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||i.NVIC_SystemHandlerConfig||, CODE, READONLY, ALIGN=2

                  NVIC_SystemHandlerConfig PROC
;;;469    *******************************************************************************/
;;;470    void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;471    {
;;;472      u32 tmpreg = 0x00;
000002  2200              MOVS     r2,#0
;;;473    
;;;474      /* Check the parameters */
;;;475      assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
;;;476      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;477      
;;;478      tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
000004  f000041f          AND      r4,r0,#0x1f
000008  2301              MOVS     r3,#1
00000a  fa03f204          LSL      r2,r3,r4
;;;479    
;;;480      if (NewState != DISABLE)
00000e  b141              CBZ      r1,|L28.34|
;;;481      {
;;;482        SCB->SHCSR |= tmpreg;
000010  4b08              LDR      r3,|L28.52|
000012  681b              LDR      r3,[r3,#0]
000014  ea430302          ORR      r3,r3,r2
000018  f04f24e0          MOV      r4,#0xe000e000
00001c  f8c43d24          STR      r3,[r4,#0xd24]
000020  e007              B        |L28.50|
                  |L28.34|
;;;483      }
;;;484      else
;;;485      {
;;;486        SCB->SHCSR &= ~tmpreg;
000022  4b04              LDR      r3,|L28.52|
000024  681b              LDR      r3,[r3,#0]
000026  ea230302          BIC      r3,r3,r2
00002a  f04f24e0          MOV      r4,#0xe000e000
00002e  f8c43d24          STR      r3,[r4,#0xd24]
                  |L28.50|
;;;487      }
;;;488    }
000032  bd10              POP      {r4,pc}
;;;489    
                          ENDP

                  |L28.52|
                          DCD      0xe000ed24

                          AREA ||i.NVIC_SystemHandlerPriorityConfig||, CODE, READONLY, ALIGN=2

                  NVIC_SystemHandlerPriorityConfig PROC
;;;509    *******************************************************************************/
;;;510    void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
000000  b5f0              PUSH     {r4-r7,lr}
;;;511                                          u8 SystemHandlerSubPriority)
;;;512    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;513      u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
000008  2000              MOVS     r0,#0
00000a  22ff              MOVS     r2,#0xff
00000c  2600              MOVS     r6,#0
;;;514      u32 tmppriority = 0x00;
00000e  2100              MOVS     r1,#0
;;;515    
;;;516      /* Check the parameters */
;;;517      assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
;;;518      assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
;;;519      assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
;;;520        
;;;521      tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
000010  4f1a              LDR      r7,|L29.124|
000012  683f              LDR      r7,[r7,#0]
000014  f40767e0          AND      r7,r7,#0x700
000018  f5c767e0          RSB      r7,r7,#0x700
00001c  ea4f2117          LSR      r1,r7,#8
;;;522      tmp1 = (0x4 - tmppriority);
000020  f1c10004          RSB      r0,r1,#4
;;;523      tmp2 = tmp2 >> tmppriority;
000024  fa22f201          LSR      r2,r2,r1
;;;524        
;;;525      tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
000028  fa04f100          LSL      r1,r4,r0
;;;526      tmppriority |=  SystemHandlerSubPriority & tmp2;
00002c  ea050702          AND      r7,r5,r2
000030  ea470101          ORR      r1,r7,r1
;;;527    
;;;528      tmppriority = tmppriority << 0x04;
000034  ea4f1101          LSL      r1,r1,#4
;;;529      tmp1 = SystemHandler & (u32)0xC0;
000038  f00300c0          AND      r0,r3,#0xc0
;;;530      tmp1 = tmp1 >> 0x06; 
00003c  ea4f1090          LSR      r0,r0,#6
;;;531      tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
000040  f3c32201          UBFX     r2,r3,#8,#2
;;;532      tmppriority = tmppriority << (tmp2 * 0x08);
000044  ea4f07c2          LSL      r7,r2,#3
000048  fa01f107          LSL      r1,r1,r7
;;;533      handlermask = (u32)0xFF << (tmp2 * 0x08);
00004c  ea4f0cc2          LSL      r12,r2,#3
000050  f04f07ff          MOV      r7,#0xff
000054  fa07f60c          LSL      r6,r7,r12
;;;534      
;;;535      SCB->SHPR[tmp1] &= ~handlermask;
000058  4f09              LDR      r7,|L29.128|
00005a  f8577020          LDR      r7,[r7,r0,LSL #2]
00005e  ea270706          BIC      r7,r7,r6
000062  f8dfc01c          LDR      r12,|L29.128|
000066  f84c7020          STR      r7,[r12,r0,LSL #2]
;;;536      SCB->SHPR[tmp1] |= tmppriority;
00006a  4667              MOV      r7,r12
00006c  f8577020          LDR      r7,[r7,r0,LSL #2]
000070  ea470701          ORR      r7,r7,r1
000074  f84c7020          STR      r7,[r12,r0,LSL #2]
;;;537    }
000078  bdf0              POP      {r4-r7,pc}
;;;538    
                          ENDP

00007a  0000              DCW      0x0000
                  |L29.124|
                          DCD      0xe000ed0c
                  |L29.128|
                          DCD      0xe000ed18

                          AREA ||i.NVIC_SystemLPConfig||, CODE, READONLY, ALIGN=2

                  NVIC_SystemLPConfig PROC
;;;439    *******************************************************************************/
;;;440    void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
000000  b141              CBZ      r1,|L30.20|
;;;441    {
;;;442      /* Check the parameters */
;;;443      assert_param(IS_NVIC_LP(LowPowerMode));
;;;444      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;445      
;;;446      if (NewState != DISABLE)
;;;447      {
;;;448        SCB->SCR |= LowPowerMode;
000002  4a09              LDR      r2,|L30.40|
000004  6812              LDR      r2,[r2,#0]
000006  ea420200          ORR      r2,r2,r0
00000a  f04f23e0          MOV      r3,#0xe000e000
00000e  f8c32d10          STR      r2,[r3,#0xd10]
000012  e007              B        |L30.36|
                  |L30.20|
;;;449      }
;;;450      else
;;;451      {
;;;452        SCB->SCR &= (u32)(~(u32)LowPowerMode);
000014  4a04              LDR      r2,|L30.40|
000016  6812              LDR      r2,[r2,#0]
000018  ea220200          BIC      r2,r2,r0
00001c  f04f23e0          MOV      r3,#0xe000e000
000020  f8c32d10          STR      r2,[r3,#0xd10]
                  |L30.36|
;;;453      }
;;;454    }
000024  4770              BX       lr
;;;455    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      0xe000ed10
